<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Ramadan Border Garland — Luxury</title>

<style>
body{
  margin:0;
  overflow:hidden;
  background:#000;
  font-family:"Noto Kufi Arabic",system-ui;
  color:white;
}
canvas{position:fixed;inset:0;width:100%;height:100%}

.ui{
  position:fixed; inset:0;
  display:flex; flex-direction:column;
  justify-content:space-between;
  padding:20px;
  pointer-events:none;
}

.title{
  text-align:center;
  margin-bottom:70px;
  opacity:0;
  transform:translateY(50px) scale(.98);
  transition:.9s cubic-bezier(.2,.8,.2,1);
  text-shadow:0 0 45px rgba(255,255,255,.35);
}
.title.on{opacity:1;transform:translateY(0) scale(1)}

.title h1{
  font-size:72px;
  margin:0;
  background:linear-gradient(90deg,#ffffff,#dddddd,#ffffff);
  -webkit-background-clip:text;
  color:transparent;
}
.title p{
  margin-top:15px;
  font-size:20px;
  opacity:.88;
}

.pop{
  position:fixed;
  left:50%;
  bottom:36px;
  transform:translateX(-50%);
  width:92px;
  height:92px;
  border-radius:50%;
  background:radial-gradient(circle,#f6d365,#ffb36b);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:26px;
  cursor:pointer;
  box-shadow:0 0 50px rgba(255,200,120,.9);
  z-index:20;
  user-select:none;
}
.pop:active{transform:translateX(-50%) scale(.92)}
</style>
</head>

<body>

<canvas id="c"></canvas>

<div class="ui">
  <div></div>
  <div class="title" id="title">
    <h1>رمضان كريم</h1>
    <p>اللهم اجعل هذا الشهر بداية نور… وراحة قلب… وخيرٍ لا ينتهي ✨</p>
  </div>
  <div></div>
</div>

<div class="pop" id="popBtn">✨</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* =========================
   SCENE
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 18, 70);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 260);
camera.position.set(0, 1.2, 22);

const renderer = new THREE.WebGLRenderer({ canvas: c, antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

window.addEventListener("resize", ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* =========================
   LIGHTS
========================= */
const ambient = new THREE.AmbientLight(0xffffff, 0.02);
scene.add(ambient);

const mainLight = new THREE.PointLight(0xffe7b0, 0, 160, 2);
mainLight.position.set(0, 10, 8);
scene.add(mainLight);

const rim = new THREE.DirectionalLight(0xbfefff, 0);
rim.position.set(-9, 2, -9);
scene.add(rim);

/* =========================
   STARS
========================= */
const starGeo = new THREE.BufferGeometry();
const starCount = 13000;
const starPos = new Float32Array(starCount*3);

for(let i=0;i<starCount;i++){
  starPos[i*3]   = (Math.random()-0.5)*180;
  starPos[i*3+1] = (Math.random()-0.5)*120;
  starPos[i*3+2] = -Math.random()*220;
}
starGeo.setAttribute("position", new THREE.BufferAttribute(starPos,3));

const stars = new THREE.Points(
  starGeo,
  new THREE.PointsMaterial({
    color:0xffffff,
    size:0.14,
    transparent:true,
    opacity:0.95,
    depthWrite:false
  })
);
scene.add(stars);

/* =========================
   GOLD DUST
========================= */
const dustGeo = new THREE.BufferGeometry();
const dustCount = 2400;
const dustPos = new Float32Array(dustCount*3);

for(let i=0;i<dustCount;i++){
  dustPos[i*3]   = (Math.random()-0.5)*28;
  dustPos[i*3+1] = (Math.random()-0.5)*18;
  dustPos[i*3+2] = -Math.random()*26;
}
dustGeo.setAttribute("position", new THREE.BufferAttribute(dustPos,3));

const dust = new THREE.Points(
  dustGeo,
  new THREE.PointsMaterial({
    color:0xffd88a,
    size:0.045,
    transparent:true,
    opacity:0.0,
    depthWrite:false
  })
);
scene.add(dust);

/* =========================
   MATERIAL HELPERS
========================= */
function goldMat(){
  return new THREE.MeshStandardMaterial({
    color:0xf6d365,
    metalness:1,
    roughness:0.18
  });
}

function bulbMat(){
  return new THREE.MeshStandardMaterial({
    color:0xfff3d0,
    emissive:0xffd88a,
    emissiveIntensity:0,
    transparent:true,
    opacity:0
  });
}

/* =========================
   LANTERN (fancy)
========================= */
function createLantern(scale=1){
  const g = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.CylinderGeometry(0.52,0.64,1.85,64,1,true),
    new THREE.MeshStandardMaterial({
      color:0xf6d365,
      metalness:0.95,
      roughness:0.25
    })
  );

  const top = new THREE.Mesh(
    new THREE.SphereGeometry(0.48,44,30),
    new THREE.MeshStandardMaterial({
      color:0xf6d365,
      metalness:1,
      roughness:0.18
    })
  );
  top.scale.set(1.35,0.62,1.35);
  top.position.y = 1.12;

  const bottom = top.clone();
  bottom.position.y = -1.12;

  const hook = new THREE.Mesh(
    new THREE.TorusGeometry(0.18,0.03,18,60),
    new THREE.MeshStandardMaterial({
      color:0xffffff,
      metalness:0.8,
      roughness:0.2
    })
  );
  hook.position.y = 1.52;
  hook.rotation.x = Math.PI/2;

  const light = new THREE.PointLight(0xffd88a, 0.0, 55, 2);
  light.position.set(0,0,0);

  g.add(body, top, bottom, hook, light);
  g.scale.setScalar(scale);

  return { g, light };
}

/* =========================
   BORDER GARLAND SYSTEM
========================= */
const borderGroup = new THREE.Group();
scene.add(borderGroup);

function makeBorderGarland(kind){
  // kind: "top" | "bottom" | "left" | "right"
  const g = new THREE.Group();

  const bulbs = [];
  const ropeParts = [];

  const z = -10;

  if(kind === "top" || kind === "bottom"){
    const y = (kind === "top") ? 7.2 : -5.4;
    const W = 22;

    // rope curve
    const pts=[];
    for(let i=0;i<=90;i++){
      const x=(i/90 - .5)*W;
      const sag = (kind === "top") ? 0.65 : -0.55;
      const yy=y + Math.sin(i/90*Math.PI)*sag;
      pts.push(new THREE.Vector3(x,yy,z));
    }
    const curve=new THREE.CatmullRomCurve3(pts);

    const ropeGeo=new THREE.TubeGeometry(curve,260,.06,12,false);
    const ropeMat=new THREE.MeshStandardMaterial({
      color:0xf6d365, metalness:1, roughness:0.18,
      transparent:true, opacity:0
    });
    const rope=new THREE.Mesh(ropeGeo,ropeMat);
    g.add(rope);
    ropeParts.push({ropeMat});

    // bulbs + drops
    const count = 26;
    for(let i=0;i<count;i++){
      const t=i/(count-1);
      const p=curve.getPoint(t);

      // small vertical drop string
      const dropLen = 0.6 + Math.random()*0.9;
      const dropGeo = new THREE.CylinderGeometry(0.01,0.01,dropLen,10);
      const dropMat = new THREE.MeshStandardMaterial({
        color:0xf6d365,
        metalness:1,
        roughness:0.2,
        transparent:true,
        opacity:0
      });
      const drop = new THREE.Mesh(dropGeo, dropMat);
      drop.position.set(p.x, p.y - dropLen/2, p.z);
      g.add(drop);

      // bulb at end
      const bulb = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 20, 20),
        bulbMat()
      );
      bulb.position.set(p.x, p.y - dropLen, p.z);

      const light = new THREE.PointLight(0xffd88a, 0.0, 22, 2);
      light.position.copy(bulb.position);

      g.add(bulb);
      g.add(light);

      bulbs.push({ bulb, light, dropMat, step:i/(count-1) });
    }

  } else {
    // left / right vertical
    const x = (kind === "left") ? -11.0 : 11.0;
    const H = 14;

    const pts=[];
    for(let i=0;i<=70;i++){
      const y=(i/70 - .5)*H + 1.0;
      const sag = (kind === "left") ? 0.65 : -0.65;
      const xx=x + Math.sin(i/70*Math.PI)*0.35*(sag/0.65);
      pts.push(new THREE.Vector3(xx,y,z));
    }
    const curve=new THREE.CatmullRomCurve3(pts);

    const ropeGeo=new THREE.TubeGeometry(curve,240,.06,12,false);
    const ropeMat=new THREE.MeshStandardMaterial({
      color:0xf6d365, metalness:1, roughness:0.18,
      transparent:true, opacity:0
    });
    const rope=new THREE.Mesh(ropeGeo,ropeMat);
    g.add(rope);
    ropeParts.push({ropeMat});

    const count = 18;
    for(let i=0;i<count;i++){
      const t=i/(count-1);
      const p=curve.getPoint(t);

      const dropLen = 0.7 + Math.random()*0.9;
      const dropGeo = new THREE.CylinderGeometry(0.01,0.01,dropLen,10);
      const dropMat = new THREE.MeshStandardMaterial({
        color:0xf6d365,
        metalness:1,
        roughness:0.2,
        transparent:true,
        opacity:0
      });
      const drop = new THREE.Mesh(dropGeo, dropMat);

      // for side ropes, drop inward
      const inward = (kind === "left") ? 0.9 : -0.9;
      drop.position.set(p.x + inward*0.25, p.y, p.z);
      drop.rotation.z = Math.PI/2;
      g.add(drop);

      const bulb = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 20, 20),
        bulbMat()
      );
      bulb.position.set(p.x + inward*0.9, p.y, p.z);

      const light = new THREE.PointLight(0xffd88a, 0.0, 22, 2);
      light.position.copy(bulb.position);

      g.add(bulb);
      g.add(light);

      bulbs.push({ bulb, light, dropMat, step:i/(count-1) });
    }
  }

  borderGroup.add(g);
  return { g, bulbs, ropeParts };
}

const Top = makeBorderGarland("top");
const Bottom = makeBorderGarland("bottom");
const Left = makeBorderGarland("left");
const Right = makeBorderGarland("right");

/* =========================
   LANTERNS HANGING FROM TOP ROPE
========================= */
function makeHangingLantern(x, y, scale){
  const L = createLantern(scale);

  // hang string
  const chainGeo = new THREE.CylinderGeometry(0.015,0.015,1.6,12);
  const chainMat = new THREE.MeshStandardMaterial({
    color:0xf6d365,
    metalness:1,
    roughness:0.2,
    transparent:true,
    opacity:0
  });
  const chain = new THREE.Mesh(chainGeo, chainMat);
  chain.position.set(x, y-0.8, -10);

  L.g.position.set(x, y-2.0, -26); // hidden at start

  scene.add(chain);
  scene.add(L.g);

  return { L, chainMat, chain };
}

const H1 = makeHangingLantern(-6.5, 7.1, 0.95);
const H2 = makeHangingLantern( 0.0, 7.0, 1.05);
const H3 = makeHangingLantern( 6.5, 7.1, 0.95);

/* =========================
   CRESCENT TOP RIGHT + STAR
========================= */
const crescent = new THREE.Group();

const outer = new THREE.Mesh(
  new THREE.TorusGeometry(1.85, 0.30, 64, 220, Math.PI * 1.6),
  new THREE.MeshStandardMaterial({
    color:0xffffff,
    metalness:0.15,
    roughness:0.22,
    emissive:0xffffff,
    emissiveIntensity:0
  })
);
outer.rotation.z = 0.42;

const inner = new THREE.Mesh(
  new THREE.TorusGeometry(1.45, 0.30, 64, 220, Math.PI * 1.6),
  new THREE.MeshBasicMaterial({ color:0x000000 })
);
inner.position.x = 0.52;
inner.rotation.copy(outer.rotation);

const smallStar = new THREE.Mesh(
  new THREE.IcosahedronGeometry(0.16, 1),
  new THREE.MeshStandardMaterial({
    color:0xffffff,
    metalness:0.2,
    roughness:0.25,
    emissive:0xffffff,
    emissiveIntensity:0
  })
);
smallStar.position.set(1.35, 0.95, 0.12);

crescent.add(outer, inner, smallStar);
crescent.position.set(8.8, 6.0, -45);
scene.add(crescent);

/* =========================
   REVEAL
========================= */
let reveal = 0;
let target = 0;

const title = document.getElementById("title");
const popBtn = document.getElementById("popBtn");

popBtn.onclick = ()=>{
  target = 1;
  title.classList.add("on");
  popBtn.style.display="none";
};

/* =========================
   ANIMATE
========================= */
function animate(){
  requestAnimationFrame(animate);
  const t = Date.now()*0.001;

  reveal += (target - reveal) * 0.05;

  // global lights
  ambient.intensity = 0.02 + reveal*0.70;
  mainLight.intensity = reveal*3.6;
  rim.intensity = reveal*0.55;

  // dust
  dust.material.opacity = reveal*0.55;
  dust.rotation.y = t*0.06;

  // border bulbs cascade + twinkle
  const borders = [Top, Bottom, Left, Right];
  borders.forEach((B, bi)=>{
    B.ropeParts.forEach(r=> r.ropeMat.opacity = reveal);

    B.bulbs.forEach((b,i)=>{
      const cascade = Math.max(0, Math.min(1, (reveal - b.step*0.45) / 0.55));
      const tw = 0.65 + Math.sin(t*2.1 + i*0.55 + bi)*0.35;

      b.bulb.material.opacity = cascade;
      b.bulb.material.emissiveIntensity = cascade*(3.2 + tw*1.8);
      b.light.intensity = cascade*(7.0 + tw*4.2);
      b.dropMat.opacity = cascade*0.9;
    });
  });

  // lanterns hanging
  const hangArr = [H1,H2,H3];
  hangArr.forEach((H,i)=>{
    H.chainMat.opacity = reveal;

    H.L.g.position.z = -26 + reveal*16;
    H.L.light.intensity = reveal*(10.5 + i*0.8);

    // swing
    const swing = 0.04 + reveal*0.12;
    H.L.g.rotation.z = Math.sin(t*0.9 + i)*swing;
    H.L.g.rotation.y = Math.sin(t*0.55 + i)*0.08;
  });

  // crescent
  crescent.position.z = -45 + reveal*18;
  crescent.rotation.y += 0.006;

  outer.material.emissiveIntensity = reveal*1.8;

  const twinkle = 0.65 + Math.sin(t*2.4)*0.35;
  smallStar.material.emissiveIntensity = reveal*(1.6 + twinkle*1.2);
  smallStar.rotation.y = -t*1.4;
  smallStar.rotation.x = t*1.1;

  // stars drift
  stars.rotation.y += 0.00045;

  // camera
  camera.position.x = Math.sin(t*0.12)*0.22;
  camera.position.y = 1.2 + Math.sin(t*0.10)*0.10;
  camera.lookAt(0, 1.0, 0);

  renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>
